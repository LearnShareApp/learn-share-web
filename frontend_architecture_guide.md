# Гайд по архитектуре фронтенда

## Оглавление

- [Гайд по архитектуре фронтенда](#гайд-по-архитектуре-фронтенда)
  - [Оглавление](#оглавление)
  - [1. Введение](#1-введение)
    - [1.1. Цель документа](#11-цель-документа)
    - [1.2. Обзор проекта](#12-обзор-проекта)
    - [1.3. Целевая аудитория](#13-целевая-аудитория)
  - [2. Обзор Технологий (Technology Stack)](#2-обзор-технологий-technology-stack)
    - [2.1. Основной фреймворк](#21-основной-фреймворк)
    - [2.2. Язык программирования](#22-язык-программирования)
    - [2.3. Библиотека UI](#23-библиотека-ui)
    - [2.4. Управление состоянием (State Management)](#24-управление-состоянием-state-management)
    - [2.5. Стилизация (Styling)](#25-стилизация-styling)
    - [2.6. Роутинг (Routing)](#26-роутинг-routing)
    - [2.7. API взаимодействие (API Communication)](#27-api-взаимодействие-api-communication)
    - [2.8. Работа с датами](#28-работа-с-датами)
    - [2.9. Видео-конференции](#29-видео-конференции)
    - [2.10. Отправка Email](#210-отправка-email)
    - [2.11. Тестирование (Testing)](#211-тестирование-testing)
    - [2.12. Линтинг и форматирование (Linting \& Formatting)](#212-линтинг-и-форматирование-linting--formatting)
    - [2.13. Сборка и развертывание (Build \& Deployment)](#213-сборка-и-развертывание-build--deployment)
  - [3. Архитектура Приложения (Application Architecture)](#3-архитектура-приложения-application-architecture)
    - [3.1. Структура директорий](#31-структура-директорий)
    - [3.2. Компонентная модель](#32-компонентная-модель)
    - [3.3. Стилизация (детально)](#33-стилизация-детально)
    - [3.4. Управление состоянием и Провайдеры (`src/providers/`)](#34-управление-состоянием-и-провайдеры-srcproviders)
    - [3.5. Кастомные хуки (`src/hooks/`)](#35-кастомные-хуки-srchooks)

## 1. Введение

### 1.1. Цель документа

Этот документ описывает архитектуру фронтенд-части проекта Learn&Share. Его цель – предоставить разработчикам четкое понимание структуры, используемых технологий, паттернов и соглашений, принятых в проекте. Гайд должен служить единым источником правды для всех вопросов, связанных с архитектурой фронтенда.

### 1.2. Обзор проекта

Проект Learn&Share — это платформа для обмена знаниями и навыками между людьми. Пользователи могут становиться как учениками, так и преподавателями, находить друг друга по интересам, общаться в чатах, проводить уроки (видеозвонки), оставлять отзывы.

Основная цель — упростить поиск наставников и учеников по любым видам деятельности: от программирования и языков до музыки и кулинарии.

### 1.3. Целевая аудитория

Этот гайд предназначен для:

- Разработчиков фронтенда, работающих над проектом.
- Технических руководителей и архитекторов.
- Новых членов команды для быстрого введения в курс дела.
- Других заинтересованных сторон, которым необходимо понимание технической реализации фронтенда.

## 2. Обзор Технологий (Technology Stack)

### 2.1. Основной фреймворк

Проект использует **Next.js** (версия 15.3.2) как основной фреймворк для серверного рендеринга (SSR), статической генерации сайтов (SSG) и создания React-приложений.

### 2.2. Язык программирования

Основным языком программирования является **TypeScript**. Это обеспечивает статическую типизацию, улучшает читаемость кода и помогает выявлять ошибки на этапе разработки.

### 2.3. Библиотека UI

В качестве основной библиотеки для построения пользовательского интерфейса используется **React** (версия 18.2.0).

### 2.4. Управление состоянием (State Management)

_На данный момент не определена конкретная библиотека для глобального управления состоянием. Предполагается использование встроенных механизмов React (useState, useReducer, Context API). Если потребуется более сложное управление состоянием, будет рассмотрена интеграция [Redux Toolkit / Zustand / Jotai / Recoil]._

### 2.5. Стилизация (Styling)

Для написания стилей используется **Sass (SCSS)** (версия 1.85.1). Это позволяет использовать переменные, миксины, вложенность и другие возможности CSS-препроцессоров для более гибкой и организованной работы со стилями.
Используются также библиотеки иконок:

- `lucide-react`
- `react-icons`

### 2.6. Роутинг (Routing)

Роутинг в приложении обрабатывается встроенной файловой системой роутинга **Next.js** (используется **App Router**).

### 2.7. API взаимодействие (API Communication)

Для взаимодействия с внешними API и бэкендом используется HTTP-клиент **Axios** (версия 1.8.3). Он предоставляет удобный интерфейс для выполнения HTTP-запросов.
Для валидации данных, получаемых от API или вводимых пользователем, используется **Zod** (версия 3.24.2).

### 2.8. Работа с датами

Для манипуляций с датами и временем используется библиотека **date-fns** (версия 4.1.0).

### 2.9. Видео-конференции

Для реализации функционала видеозвонков интегрирована платформа **LiveKit** с использованием следующих пакетов:

- `@livekit/components-react`
- `@livekit/components-styles`
- `livekit-client`

### 2.10. Отправка Email

Для отправки электронных писем со стороны клиента используется **@emailjs/browser**.

### 2.11. Тестирование (Testing)

_[Информация о фреймворках и подходах к тестированию будет добавлена позже. Рассматриваются Jest, React Testing Library, Cypress.]_

### 2.12. Линтинг и форматирование (Linting & Formatting)

Для обеспечения единообразия кода и отлова потенциальных ошибок используется **ESLint** (версия 9) с конфигурацией `eslint-config-next`. Рекомендуется использовать Prettier для автоматического форматирования кода (конфигурация Prettier будет добавлена, если еще не используется).

### 2.13. Сборка и развертывание (Build & Deployment)

Сборка проекта осуществляется с помощью команд Next.js (`next build`). Информация о процессе развертывания будет добавлена позже.

## 3. Архитектура Приложения (Application Architecture)

### 3.1. Структура директорий

Проект следует модульной структуре в рамках директории `src/`:

- **`src/app/`**: Основа роутинга с использованием **App Router** Next.js. Содержит:

  - Файлы `page.tsx` для определения публично доступных маршрутов.
  - Файлы `layout.tsx` для определения макетов страниц.
  - Файлы `loading.tsx` для состояний загрузки.
  - Файлы `error.tsx` для обработки ошибок в сегментах маршрута.
  - Компоненты сервера (Server Components) и клиентские компоненты (Client Components).
  - Возможность создания API эндпоинтов с помощью Route Handlers (файлы `route.ts` или `route.js`).

- **`src/components/`**: Директория для общих, переиспользуемых UI-компонентов, которые не привязаны к конкретной фиче или странице (например, кнопки, инпуты, модальные окна).

- **`src/features/`**: Содержит модули, сгруппированные по функциональным возможностям приложения (фичам). Каждый модуль фичи может включать в себя собственные компоненты, хуки, сервисы, типы, относящиеся к данной фиче. Это помогает инкапсулировать логику и делает кодовую базу более управляемой.
  _Пример структуры внутри фичи: `src/features/LessonItem.tsx`_

- **`src/hooks/`**: Для кастомных React хуков, которые могут быть переиспользованы в различных частях приложения (например, `useDebounce`, `useLocalStorage`).

- **`src/layouts/`**: Может содержать более сложные или специфические макеты, которые используются несколькими страницами или компонентами, или компоненты, используемые в корневом `app/layout.tsx`.

- **`src/locales/`**: Для файлов локализации, если в проекте используется интернационализация (i18n). Содержит файлы с переводами для различных языков.

- **`src/providers/`**: Директория для React Context провайдеров. Используется для предоставления глобального состояния или зависимостей компонентам ниже по дереву (например, `ThemeProvider`, `AuthProvider`).

- **`src/styles/`**: Для глобальных стилей, переменных Sass/SCSS, миксинов, утилитных CSS-классов и базовых стилей для HTML-элементов.

- **`src/types/`**: Содержит глобальные определения типов и интерфейсов TypeScript, которые используются в нескольких частях приложения.

- **`src/utilities/`**: Для вспомогательных функций, которые не являются хуками и не относятся к конкретной фиче (например, функции форматирования данных, валидаторы и т.д.).

### 3.2. Компонентная модель

В проекте принята компонентная архитектура, которая способствует переиспользованию кода, его тестируемости и разделению ответственности. Компоненты в основном разделяются на две категории в зависимости от их расположения и назначения:

1. **Общие (UI) компоненты (`src/components/`)**

   - **Назначение**: Эта директория содержит универсальные, переиспользуемые UI-компоненты, которые не обладают специфической бизнес-логикой и не привязаны к конкретной функциональности (фиче) приложения. Они служат строительными блоками для пользовательского интерфейса.
   - **Характеристики**:
     - Часто являются "глупыми" (dumb/presentational) компонентами: получают данные и колбэки через props и отвечают только за отображение.
     - Легко стилизуются и могут иметь различные варианты отображения.
     - Примеры: `Button`, `Input`, `Modal`, `Spinner`, `Icon`, `Card`.
   - **Цель**: Обеспечить консистентность UI по всему приложению и избежать дублирования кода базовых элементов интерфейса.

2. **Компоненты фич (`src/features/`)**
   - **Назначение**: Эта директория содержит компоненты, которые относятся к конкретным функциональным модулям (фичам) приложения. Например, фича "Аутентификация" (`src/features/auth/`) может содержать `LoginForm`, `RegistrationForm`, `UserProfilePreview`.
   - **Характеристики**:
     - Могут быть как "умными" (smart/container) компонентами, так и "глупыми" (presentational).
       - **Умные компоненты фич**: Управляют состоянием, связанным с фичей, выполняют запросы к API, обрабатывают бизнес-логику и передают данные презентационным компонентам.
       - **Презентационные компоненты фич**: Отвечают за отображение данных конкретной фичи и могут быть составлены из общих UI-компонентов из `src/components/` или быть специфичными для данной фичи.
     - Инкапсулируют логику и структуру конкретной фичи, делая ее более независимой и тестируемой.
   - **Цель**: Структурировать код приложения по бизнес-доменам, улучшая его понимание и масштабируемость.

**Взаимодействие компонентов:**

- Компоненты из `src/features/` могут использовать (импортировать) общие UI-компоненты из `src/components/`.
- Общие UI-компоненты из `src/components/` не должны зависеть от компонентов или логики из `src/features/`.

**Next.js App Router и компоненты:**

- **Серверные компоненты (Server Components)**: По умолчанию компоненты в App Router являются серверными. Они выполняются на сервере и могут напрямую работать с источниками данных (например, выполнять асинхронные операции для получения данных). Они не используют React хуки, такие как `useState` или `useEffect`, и не могут быть интерактивными.
- **Клиентские компоненты (Client Components)**: Для добавления интерактивности (обработчики событий, состояние, эффекты) компоненты должны быть помечены директивой `"use client"` в начале файла. Клиентские компоненты выполняются как на сервере (для первоначального рендера), так и в браузере.
- **Рекомендации**:
  - Старайтесь размещать логику получения данных и неинтерактивное отображение в Серверных компонентах (например, в `page.tsx` или компонентах, которые они импортируют).
  - Используйте Клиентские компоненты только там, где это необходимо для интерактивности.
  - Размещайте директиву `"use client"` как можно глубже в дереве компонентов (т.е. не в корневом компоненте фичи, если только небольшая его часть требует интерактивности).

### 3.3. Стилизация (детально)

Проект использует **Sass (SCSS)** в сочетании с **CSS Modules** для стилизации компонентов и страниц.

**Основные файлы и конвенции:**

1.  **Глобальные стили (`src/styles/globals.scss`)**:

    - Этот файл предназначен для определения глобальных стилей, которые применяются ко всему приложению.
    - Сюда могут входить: сброс стилей браузера (reset/normalize), базовые стили для HTML-тегов (`body`, `h1`, `p` и т.д.), основные стили макета, CSS-переменные (хотя для SCSS переменных предпочтительнее `variables.scss`).
    - Этот файл импортируется в корневом макете приложения (`src/app/layout.tsx`).

2.  **SCSS Переменные (`src/styles/variables.scss`)**:

    - Этот файл содержит все SCSS переменные, используемые в проекте: цвета, шрифты, размеры отступов, контрольные точки (breakpoints) для адаптивности и т.д.
    - Он импортируется в другие SCSS-файлы (глобальные или модульные), где необходим доступ к этим переменным (например, с помощью `@import "@/styles/variables.scss";` или `@use "@/styles/variables" as *;` если настроены алиасы).

3.  **Модульные стили (`*.module.scss`)**:
    - Для стилизации отдельных страниц и компонентов используются CSS Modules. Файлы стилей именуются как `[ComponentName].module.scss` (для компонентов) или `page.module.scss` (для страниц).
    - **Локальная область видимости**: CSS Modules автоматически генерируют уникальные имена классов (например, `MyComponent_className__uniqueHash`), что предотвращает конфликты стилей между компонентами.
    - **Использование в компонентах**: Стили импортируются в компонент как объект, и классы применяются через этот объект: `import styles from './MyComponent.module.scss'; <div className={styles.myClass}>...</div>`.
    - **Композиция классов**: CSS Modules позволяют легко комбинировать классы.
    - Внутри `*.module.scss` файлов можно использовать переменные из `variables.scss` и другие возможности Sass.

**Рекомендации:**

- Предпочитайте модульные стили для всего, что является компонентом или страницей.
- Используйте глобальные стили только для действительно глобальных правил.
- Поддерживайте актуальность и хорошую организацию в `variables.scss`.

### 3.4. Управление состоянием и Провайдеры (`src/providers/`)

Как упоминалось в разделе "Обзор Технологий", для глобального управления состоянием в проекте на начальном этапе предполагается использование встроенных механизмов React: `useState`, `useReducer` и **React Context API**.

Директория `src/providers/` предназначена для размещения React Context провайдеров. Провайдеры контекста позволяют передавать данные через дерево компонентов без необходимости передавать props на каждом уровне вручную.

**Назначение и примеры использования `src/providers/`:**

1.  **Аутентификация (`ProfileProvider.tsx`)**:

    - Хранение состояния аутентификации пользователя (например, информация о текущем пользователе, токен доступа).
    - Предоставление методов для входа (`login`), выхода (`logout`), регистрации.
    - Защита роутов и компонентов в зависимости от статуса аутентификации.

2.  **Управление темой (`LanguageProvider.tsx`)**:

    - Используется для передачи и использования локализации.

**Структура провайдера:**

Типичный провайдер контекста включает:

- Создание контекста с помощью `createContext()`.
- Компонент-провайдер, который использует `useState` или `useReducer` для управления состоянием и передает это состояние и функции для его изменения через `Context.Provider`.
- Кастомный хук (например, `useAuth()`, `useTheme()`) для удобного доступа к значениям контекста в компонентах-потребителях.

**Рекомендации:**

- Используйте Context API для состояния, которое действительно является глобальным или должно быть доступно во многих частях приложения.
- Для локального состояния компонентов продолжайте использовать `useState` и `useReducer`.
- Избегайте помещения в контекст слишком часто обновляемых данных, так как это может привести к ненужным повторным рендерам компонентов-потребителей. Рассмотрите возможность разделения контекстов на более мелкие и специфичные.
- Провайдеры обычно размещаются в корневом макете (`src/app/layout.tsx`) или в макетах определенных сегментов роутов, чтобы обернуть нужную часть приложения.

### 3.5. Кастомные хуки (`src/hooks/`)

Кастомные хуки в React — это функции JavaScript, имена которых начинаются с `use`, и которые могут вызывать другие хуки (например, `useState`, `useEffect`, `useContext`). Они позволяют выносить логику состояния и побочные эффекты из компонентов в переиспользуемые функции.

Директория `src/hooks/` предназначена для хранения таких кастомных хуков, которые могут быть использованы в различных компонентах или даже в других кастомных хуках по всему приложению.

**Назначение и преимущества использования `src/hooks/`:**

1.  **Переиспользование логики**: Основное преимущество — возможность избежать дублирования кода. Если несколько компонентов используют одну и ту же сложную логику (например, работа с API, подписка на события, управление формой), эту логику можно вынести в кастомный хук.
2.  **Улучшение читаемости компонентов**: Компоненты становятся чище и больше фокусируются на отображении, так как сложная логика инкапсулирована в хуках.
3.  **Разделение ответственности**: Хуки помогают лучше разделить логику состояния от UI.
4.  **Тестируемость**: Логику, вынесенную в хук, легче тестировать изолированно.

**Примеры кастомных хуков:**

- **`useTeacher()`**: Для определяет являешься ли ты преподавателем.
- **`useUserProfile(id?)`**: Без передачи айди выдает твой профиль, с передачей - получает профиль по айди.

**Соглашения по именованию и расположению:**

- Имена кастомных хуков всегда должны начинаться с `use`.
- Хуки, специфичные для определенной фичи, могут располагаться внутри директории этой фичи (например, `src/features/chat/hooks/useChatMessages.ts`). Глобальные, переиспользуемые хуки размещаются в `src/hooks/`.

**Рекомендации:**

- Создавайте кастомный хук, если вы замечаете, что копируете и вставляете одну и ту же логику с хуками в нескольких компонентах.
- Старайтесь делать хуки максимально универсальными и переиспользуемыми, если это возможно.
- Хорошо документируйте, что делает хук, какие параметры он принимает и что возвращает.

<!-- Остальные разделы будут добавлены позже -->
